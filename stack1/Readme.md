## Stack 1

So for this stage we're given the following code:

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

This challenge is pretty much like the last one, only intead of just modifying the modified variable to not zero, we have to specifically modify it to 0x61626364. Let's jump back into GDB.

```assembly
gdb) disas main
Dump of assembler code for function main:
0x08048464 <main+0>:	push   %ebp
0x08048465 <main+1>:	mov    %esp,%ebp
0x08048467 <main+3>:	and    $0xfffffff0,%esp
0x0804846a <main+6>:	sub    $0x60,%esp
0x0804846d <main+9>:	cmpl   $0x1,0x8(%ebp)
0x08048471 <main+13>:	jne    0x8048487 <main+35>
0x08048473 <main+15>:	movl   $0x80485a0,0x4(%esp)
0x0804847b <main+23>:	movl   $0x1,(%esp)
0x08048482 <main+30>:	call   0x8048388 <errx@plt>
0x08048487 <main+35>:	movl   $0x0,0x5c(%esp)
0x0804848f <main+43>:	mov    0xc(%ebp),%eax
0x08048492 <main+46>:	add    $0x4,%eax
0x08048495 <main+49>:	mov    (%eax),%eax
0x08048497 <main+51>:	mov    %eax,0x4(%esp)
0x0804849b <main+55>:	lea    0x1c(%esp),%eax
0x0804849f <main+59>:	mov    %eax,(%esp)
0x080484a2 <main+62>:	call   0x8048368 <strcpy@plt>
0x080484a7 <main+67>:	mov    0x5c(%esp),%eax
0x080484ab <main+71>:	cmp    $0x61626364,%eax
0x080484b0 <main+76>:	jne    0x80484c0 <main+92>
0x080484b2 <main+78>:	movl   $0x80485bc,(%esp)
0x080484b9 <main+85>:	call   0x8048398 <puts@plt>
0x080484be <main+90>:	jmp    0x80484d5 <main+113>
0x080484c0 <main+92>:	mov    0x5c(%esp),%edx
0x080484c4 <main+96>:	mov    $0x80485f3,%eax
0x080484c9 <main+101>:	mov    %edx,0x4(%esp)
0x080484cd <main+105>:	mov    %eax,(%esp)
0x080484d0 <main+108>:	call   0x8048378 <printf@plt>
0x080484d5 <main+113>:	leave  
0x080484d6 <main+114>:	ret    
End of assembler dump.
```

There's a lot more assembly code here then before, but we can ignore some of it. The first part of the program simply sets up the stack (```<main+0>``` - ```<main+6>```) and then checks to see if there's only one argument (```<main+13>:   jne    0x8048487```) if there is it calls the errx function (```<main+30>:   call   0x8048388 <errx@plt>```).

####ignore
```assembly
gdb) disas main
Dump of assembler code for function main:
0x08048464 <main+0>:    push   %ebp
0x08048465 <main+1>:    mov    %esp,%ebp
0x08048467 <main+3>:    and    $0xfffffff0,%esp
0x0804846a <main+6>:    sub    $0x60,%esp
0x0804846d <main+9>:    cmpl   $0x1,0x8(%ebp)
0x08048471 <main+13>:   jne    0x8048487 <main+35>
0x08048473 <main+15>:   movl   $0x80485a0,0x4(%esp)
0x0804847b <main+23>:   movl   $0x1,(%esp)
0x08048482 <main+30>:   call   0x8048388 <errx@plt>
```

If we look starting at ```0x08048487 <main+35>:	movl   $0x0,0x5c(%esp)``` we see the variable modified being set, also if we jump down to ```0x0804849b <main+55>:	lea    0x1c(%esp),%eax```, we can find the starting address of where strcpy will start to write. Let's look at those addresses in GDB while giving the input aaaaaaaaaa

#### Assigning modified
```assembly
(gdb) x/i $eip
0x8048487 <main+35>:	movl   $0x0,0x5c(%esp)
(gdb) x/10x $esp + 0x5c
0xbffff78c:	0xb7fd7ff4	0x080484f0	0x00000000	0xbffff818
0xbffff79c:	0xb7eadc76	0x00000002	0xbffff844	0xbffff850
0xbffff7ac:	0xb7fe1848	0xbffff800
(gdb) si
16	in stack1/stack1.c
(gdb) x/10x $esp + 0x5c
0xbffff78c:	0x00000000	0x080484f0	0x00000000	0xbffff818
0xbffff79c:	0xb7eadc76	0x00000002	0xbffff844	0xbffff850
0xbffff7ac:	0xb7fe1848	0xbffff800
```
#### Writing to Buffer
```assembly
gdb) x/i $eip
0x804849b <main+55>:	lea    0x1c(%esp),%eax
(gdb) i r $eax
eax            0xbffff97d	-1073743491
(gdb) i r $esp
esp            0xbffff730	0xbffff730
(gdb) si
0x0804849f	16	in stack1/stack1.c
(gdb) i r $eax
eax            0xbffff74c	-1073744052
gdb) x/20x $esp +0x1c
0xbffff74c:	0x61616161	0x61616161	0x08006161	0xbffff768
0xbffff75c:	0x08048334	0xb7ff1040	0x080496fc	0xbffff798
0xbffff76c:	0x08048509	0xb7fd8304	0xb7fd7ff4	0x080484f0
0xbffff77c:	0xbffff798	0xb7ec6365	0xb7ff1040	0x080484fb
0xbffff78c:	0x00000000	0x080484f0	0x00000000	0xbffff818
```

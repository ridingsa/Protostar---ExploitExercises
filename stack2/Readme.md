## Stack 2

So for this stage we're given the following code:

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```

Much like the last challenge we have to overwrite the modified variable with a specific value. However, instead of getting input directly from the user, we're using environment variables. 

```assembly
(gdb) disas main
Dump of assembler code for function main:
0x08048494 <main+0>:	push   %ebp
0x08048495 <main+1>:	mov    %esp,%ebp
0x08048497 <main+3>:	and    $0xfffffff0,%esp
0x0804849a <main+6>:	sub    $0x60,%esp
0x0804849d <main+9>:	movl   $0x80485e0,(%esp)
0x080484a4 <main+16>:	call   0x804837c <getenv@plt>
0x080484a9 <main+21>:	mov    %eax,0x5c(%esp)
0x080484ad <main+25>:	cmpl   $0x0,0x5c(%esp)
0x080484b2 <main+30>:	jne    0x80484c8 <main+52>
0x080484b4 <main+32>:	movl   $0x80485e8,0x4(%esp)
0x080484bc <main+40>:	movl   $0x1,(%esp)
0x080484c3 <main+47>:	call   0x80483bc <errx@plt>
0x080484c8 <main+52>:	movl   $0x0,0x58(%esp)
0x080484d0 <main+60>:	mov    0x5c(%esp),%eax
0x080484d4 <main+64>:	mov    %eax,0x4(%esp)
0x080484d8 <main+68>:	lea    0x18(%esp),%eax
0x080484dc <main+72>:	mov    %eax,(%esp)
0x080484df <main+75>:	call   0x804839c <strcpy@plt>
0x080484e4 <main+80>:	mov    0x58(%esp),%eax
0x080484e8 <main+84>:	cmp    $0xd0a0d0a,%eax
0x080484ed <main+89>:	jne    0x80484fd <main+105>
0x080484ef <main+91>:	movl   $0x8048618,(%esp)
0x080484f6 <main+98>:	call   0x80483cc <puts@plt>
0x080484fb <main+103>:	jmp    0x8048512 <main+126>
0x080484fd <main+105>:	mov    0x58(%esp),%edx
0x08048501 <main+109>:	mov    $0x8048641,%eax
0x08048506 <main+114>:	mov    %edx,0x4(%esp)
0x0804850a <main+118>:	mov    %eax,(%esp)
0x0804850d <main+121>:	call   0x80483ac <printf@plt>
0x08048512 <main+126>:	leave  
0x08048513 <main+127>:	ret    
```
The assembly dumps just gets longer and longer. 
